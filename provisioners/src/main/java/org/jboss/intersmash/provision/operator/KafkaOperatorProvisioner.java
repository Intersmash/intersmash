/**
 * Copyright (C) 2023 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jboss.intersmash.provision.operator;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

import org.jboss.intersmash.IntersmashConfig;
import org.jboss.intersmash.application.operator.KafkaOperatorApplication;
import org.jboss.intersmash.provision.Provisioner;
import org.slf4j.event.Level;

import cz.xtf.core.waiting.SimpleWaiter;
import cz.xtf.core.waiting.failfast.FailFastCheck;
import io.fabric8.kubernetes.api.model.DeletionPropagation;
import io.fabric8.kubernetes.api.model.Pod;
import io.fabric8.kubernetes.api.model.StatusDetails;
import io.fabric8.kubernetes.api.model.apiextensions.v1.CustomResourceDefinition;
import io.fabric8.kubernetes.api.model.apiextensions.v1.CustomResourceDefinitionList;
import io.fabric8.kubernetes.client.NamespacedKubernetesClient;
import io.fabric8.kubernetes.client.dsl.NonNamespaceOperation;
import io.fabric8.kubernetes.client.dsl.Resource;
import io.strimzi.api.kafka.Crds;
import io.strimzi.api.kafka.model.kafka.Kafka;
import io.strimzi.api.kafka.model.kafka.KafkaList;
import io.strimzi.api.kafka.model.nodepool.KafkaNodePool;
import io.strimzi.api.kafka.model.nodepool.KafkaNodePoolList;
import io.strimzi.api.kafka.model.topic.KafkaTopic;
import io.strimzi.api.kafka.model.topic.KafkaTopicList;
import io.strimzi.api.kafka.model.user.KafkaUser;
import io.strimzi.api.kafka.model.user.KafkaUserList;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

/**
 * Deploys an application that implements {@link KafkaOperatorApplication} interface via the
 * Strimzi/Streams for Apache Kafka operator.
 */
@Slf4j
public abstract class KafkaOperatorProvisioner<C extends NamespacedKubernetesClient> extends
		OperatorProvisioner<KafkaOperatorApplication, C> implements Provisioner<KafkaOperatorApplication> {

	public KafkaOperatorProvisioner(@NonNull KafkaOperatorApplication application) {
		super(application, KafkaOperatorProvisioner.OPERATOR_ID);
	}

	// =================================================================================================================
	// Kafka related
	// =================================================================================================================
	/**
	 * Provides access to the list of Strimzi/Streams for Apache Kafka operator pods.
	 * @return A list of {@link Pod} instances representing Strimzi/Streams for Apache Kafka operator pods.
	 */
	public List<Pod> getClusterOperatorPods() {
		return this.client().pods().inNamespace(this.client().getNamespace())
				.withLabel("strimzi.io/kind", "cluster-operator").list().getItems();
	}

	/**
	 * Get list of all Kafka pods on OpenShift instance with regards this Kafka cluster.
	 * <p>
	 * @return list of Kafka broker pods
	 */
	public List<Pod> getKafkaPods() {
		return this.client().pods().inNamespace(this.client().getNamespace())
				.withLabels(Map.of("app.kubernetes.io/name", "kafka", "strimzi.io/broker-role", "true"))
				.list().getItems();
	}

	/**
	 * Get list of all Zookeeper pods on OpenShift instance with regards this Kafka cluster.
	 * <br><br>
	 * Note: Operator actually creates also pods for Kafka, instance entity operator pods and cluster operator pod.
	 * But we list only Zookeeper related pods here.
	 * @return list of Kafka pods
	 */
	public List<Pod> getZookeeperPods() {
		List<Pod> pods = this.client().pods().inNamespace(this.client().getNamespace())
				.withLabel("app.kubernetes.io/name", "zookeeper").list().getItems();
		// Let's filter out just those who match particular naming
		for (Pod pod : pods) {
			if (!pod.getMetadata().getName().contains(getApplication().getName() + "-zookeeper-")) {
				pods.remove(pod);
			}
		}
		return pods;
	}

	/**
	 * When operating in KRaft mode, returns the pods generated by the {@link io.strimzi.api.kafka.model.nodepool.KafkaNodePool} CR
	 * having the {@code role} set to {@link io.strimzi.api.kafka.model.nodepool.ProcessRoles#CONTROLLER}
	 *
	 * @return A list of {@link Pod} instances that represent the Kafka KRaft {@code controller} nodes.
	 */
	public List<Pod> getControllerNodePoolPods() {
		return this.client().pods().inNamespace(this.client().getNamespace())
				.withLabel(KafkaOperatorApplication.STRIMZI_IO_KAFKA_LABEL_CONTROLLER_ROLE, "true").list().getItems();
	}

	/**
	 * When operating in KRaft mode, returns the pods generated by the {@link io.strimzi.api.kafka.model.nodepool.KafkaNodePool} CR
	 * having the {@code role} set to {@link io.strimzi.api.kafka.model.nodepool.ProcessRoles#BROKER}
	 *
	 * @return A list of {@link Pod} instances that represent the Kafka KRaft {@code broker} nodes.
	 */
	public List<Pod> getBrokerNodePoolPods() {
		return this.client().pods().inNamespace(this.client().getNamespace())
				.withLabel(KafkaOperatorApplication.STRIMZI_IO_KAFKA_LABEL_BROKER_ROLE, "true").list().getItems();
	}

	public void waitForKafkaClusterCreation() {
		FailFastCheck ffCheck = getFailFastCheck();
		int expectedReplicas = getApplication().getKafka().getSpec().getKafka().getReplicas();
		new SimpleWaiter(() -> getKafkaResource().get() != null)
				.failFast(ffCheck)
				.reason("Wait for Kafka cluster instance to be initialized.")
				.level(Level.DEBUG)
				.waitFor();
		new SimpleWaiter(() -> getKafkaResource().get().getStatus() != null)
				.failFast(ffCheck)
				.reason("Wait for a status field of the Kafka cluster instance to be initialized.")
				.level(Level.DEBUG)
				.waitFor();
		new SimpleWaiter(() -> getKafkaResource().get().getStatus().getConditions() != null)
				.failFast(ffCheck)
				.reason("Wait for a conditions field of the Kafka cluster instance to be initialized.")
				.level(Level.DEBUG)
				.waitFor();
		new SimpleWaiter(() -> !getKafkaResource().get().getStatus().getConditions().isEmpty())
				.failFast(ffCheck)
				.reason("Wait for a conditions field of the Kafka cluster instance to contain at least one condition.")
				.level(Level.DEBUG)
				.waitFor();
		new SimpleWaiter(
				() -> getKafkaResource().get().getStatus().getConditions().stream()
						.anyMatch(c -> "Ready".equals(c.getType()) && "True".equals(c.getStatus())))
				.failFast(ffCheck)
				.reason("Wait for a conditions field of the Kafka cluster instance to be in state 'Ready'.")
				.level(Level.DEBUG)
				.onSuccess(() -> {
					listKafkaClusterCreationConditions(true,
							"Waiting for the Kafka cluster instance was successful.");
				})
				.onFailure(() -> {
					listKafkaClusterCreationConditions(false,
							"Waiting for the Kafka cluster instance ended with an error.");
				})
				.onTimeout(() -> {
					listKafkaClusterCreationConditions(false,
							"Waiting for the Kafka cluster instance ended with a timeout.");
				})
				.waitFor();
		new SimpleWaiter(() -> getKafkaPods().size() == expectedReplicas)
				.failFast(ffCheck)
				.reason("Wait for expected number of replicas of Kafka to be active.")
				.level(Level.DEBUG)
				.waitFor();
	}

	private void listKafkaClusterCreationConditions(boolean success, String message) {
		String completeMessage = message + " Here is the list of instance conditions found there:";
		if (success) {
			log.info(completeMessage);
		} else {
			log.error(completeMessage);
		}

		getKafkaResource().get().getStatus().getConditions().stream().forEach(c -> {
			String conditionMessage = "    |- " + c.getType() + ":" + c.getStatus() + ":" + c.getMessage();
			if (success) {
				log.info(conditionMessage);
			} else {
				log.error(conditionMessage);
			}
		});
	}

	private void waitForKafkaTopicCreation(KafkaTopic topic) {
		String topicName = topic.getMetadata().getName();

		new SimpleWaiter(() -> getKafkaTopicResources().getItems().stream().filter(
				t -> topicName.equals(t.getMetadata().getName())).count() == 1,
				"Waiting for topic '" + topicName + "' to be created").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaTopicResources().getItems().stream().filter(
				t -> topicName.equals(t.getMetadata().getName())).allMatch(t -> t.getStatus() != null),
				"Waiting for topic '" + topicName + "' status is non-null").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaTopicResources().getItems().stream().filter(
				t -> topicName.equals(t.getMetadata().getName())).allMatch(t -> t.getStatus().getConditions() != null),
				"Waiting for topic '" + topicName + "' conditions are non-null").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaTopicResources().getItems().stream().filter(
				t -> topicName.equals(t.getMetadata().getName())).allMatch(
						t -> t.getStatus().getConditions().size() > 0),
				"Waiting for topic '" + topicName + "' conditions size is greater than 0").level(
						Level.DEBUG)
				.waitFor();

		new SimpleWaiter(() -> getKafkaTopicResources().getItems().stream().filter(
				t -> topicName.equals(t.getMetadata().getName())).allMatch(
						t -> "Ready".equals(t.getStatus().getConditions().get(0).getType())),
				"Waiting for topic '" + topicName + "' condition to be 'Ready'").level(Level.DEBUG).waitFor();
	}

	private void waitForKafkaUserCreation(KafkaUser user) {
		String userName = user.getMetadata().getName();

		new SimpleWaiter(() -> getKafkaUserResources().getItems().stream().filter(
				u -> userName.equals(u.getMetadata().getName())).count() == 1,
				"Waiting for user '" + userName + "' to be created").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaUserResources().getItems().stream().filter(
				u -> userName.equals(u.getMetadata().getName())).allMatch(u -> u.getStatus() != null),
				"Waiting for user '" + userName + "' status is non-null").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaUserResources().getItems().stream().filter(
				u -> userName.equals(u.getMetadata().getName())).allMatch(u -> u.getStatus().getConditions() != null),
				"Waiting for user '" + userName + "' conditions are non-null").level(Level.DEBUG).waitFor();

		new SimpleWaiter(() -> getKafkaUserResources().getItems().stream().filter(
				u -> userName.equals(u.getMetadata().getName())).allMatch(
						u -> u.getStatus().getConditions().size() > 0),
				"Waiting for user '" + userName + "' conditions size is greater than 0").level(
						Level.DEBUG)
				.waitFor();

		new SimpleWaiter(() -> getKafkaUserResources().getItems().stream().filter(
				u -> userName.equals(u.getMetadata().getName())).allMatch(
						u -> "Ready".equals(u.getStatus().getConditions().get(0).getType())),
				"Waiting for user '" + userName + "' condition to be 'Ready'").level(Level.DEBUG).waitFor();
	}

	// =================================================================================================================
	// Related to generic operator provisioning behavior
	// =================================================================================================================
	@Override
	protected String getOperatorCatalogSource() {
		return IntersmashConfig.kafkaOperatorCatalogSource();
	}

	@Override
	protected String getOperatorIndexImage() {
		return IntersmashConfig.kafkaOperatorIndexImage();
	}

	@Override
	protected String getOperatorChannel() {
		return IntersmashConfig.kafkaOperatorChannel();
	}

	@Override
	public List<Pod> getPods() {
		return this.client().pods().inNamespace(this.client().getNamespace())
				.withLabel("strimzi.io/cluster", getApplication().getName()).list().getItems();
	}

	@Override
	public void deploy() {
		subscribe();
		final Kafka applicationKafka = getApplication().getKafka();
		if (applicationKafka != null) {
			final boolean isKRaftModeEnabled = getApplication().isKRaftModeEnabled();
			final List<KafkaNodePool> applicationKafkaNodePools = getApplication().getNodePools();
			// When KRaft mode is enabled, first create KafkaNodePool resources
			if (isKRaftModeEnabled) {
				applicationKafkaNodePools.stream().forEach(np -> kafkaNodePoolResourceClient().resource(np).create());
			}
			// Create a Kafka cluster instance
			kafkaResourceClient().resource(applicationKafka).create();
			waitForKafkaClusterCreation();
		}
		final List<KafkaTopic> applicationKafkaTopics = getApplication().getTopics();
		if (applicationKafkaTopics != null) {
			applicationKafkaTopics.stream().forEach(topic -> {
				// Create a Kafka topic instance
				kafkaTopicResourceClient().resource(topic).create();
				// Wait for it to be created and ready...
				waitForKafkaTopicCreation(topic);
			});
		}
		final List<KafkaUser> applicationKafkaUsers = getApplication().getUsers();
		if (applicationKafkaUsers != null) {
			applicationKafkaUsers.stream().forEach(user -> {
				// Create a Kafka user instance
				kafkaUserResourceClient().resource(user).create();
				// Wait for it to be created and ready...
				waitForKafkaUserCreation(user);
			});
		}
	}

	@Override
	public void undeploy() {
		// delete the resources
		List<StatusDetails> deletionDetails;
		boolean deleted;
		if (getApplication().getUsers() != null) {
			deletionDetails = kafkaUserResourceClient().delete();
			deleted = deletionDetails.stream().allMatch(d -> d.getCauses().isEmpty());
			if (!deleted) {
				log.warn("Wasn't able to remove all relevant 'Kafka User' resources created for '{}' instance!",
						getApplication().getName());
			}
			new SimpleWaiter(() -> kafkaUserResourceClient().list().getItems().isEmpty()).level(Level.DEBUG).waitFor();
		}
		if (getApplication().getTopics() != null) {
			deletionDetails = kafkaTopicResourceClient().delete();
			deleted = deletionDetails.stream().allMatch(d -> d.getCauses().isEmpty());
			if (!deleted) {
				log.warn("Wasn't able to remove all relevant 'Kafka Topic' resources created for '{}' instance!",
						getApplication().getName());
			}
			new SimpleWaiter(() -> kafkaTopicResourceClient().list().getItems().isEmpty()).level(Level.DEBUG).waitFor();
		}
		if (getApplication().getKafka() != null) {
			deletionDetails = kafkaResourceClient().withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();
			deleted = deletionDetails.stream().allMatch(d -> d.getCauses().isEmpty());
			if (!deleted) {
				log.warn("Wasn't able to remove all relevant 'Kafka' resources created for '{}' instance!",
						getApplication().getName());
			}
			// remove also KafkaNodePool CRs when in KRaft mode
			if (getApplication().isKRaftModeEnabled()) {
				deletionDetails = kafkaNodePoolResourceClient().delete();
				deleted = deletionDetails.stream().allMatch(d -> d.getCauses().isEmpty());
				if (!deleted) {
					log.warn("Wasn't able to remove all relevant 'KafkaNodePool' CRs created for '{}' instance!",
							getApplication().getName());
				}
				new SimpleWaiter(() -> kafkaNodePoolResourceClient().list().getItems().isEmpty()).level(Level.DEBUG).waitFor();
			}
			new SimpleWaiter(() -> getKafkaPods().isEmpty()).level(Level.DEBUG).waitFor();
		}
		unsubscribe();
		BooleanSupplier bs = () -> getPods().stream().noneMatch(p -> p.getMetadata().getLabels().get("name") != null
				&& p.getMetadata().getLabels().get("name").equals(getApplication().getName() + "-cluster-operator"));
		new SimpleWaiter(bs, TimeUnit.MINUTES, 2,
				"Waiting for 0 pods with label \"name\"=" + getApplication().getName() + "-cluster-operator")
				.waitFor();
	}

	@Override
	public void scale(int replicas, boolean wait) {
		final Kafka kafka = getApplication().getKafka();
		kafka.getSpec().getKafka().setReplicas(replicas);
		kafkaResourceClient().resource(kafka).update();
		if (wait) {
			waitForKafkaClusterCreation();
		}
	}

	// =================================================================================================================
	// Client related
	// =================================================================================================================
	// this is the packagemanifest for the operator as obtained with the following command:
	// oc get packagemanifest <operator-csv> -o template --template='{{ .metadata.name }}'
	public static String OPERATOR_ID = IntersmashConfig.kafkaOperatorPackageManifest();

	/**
	 * Generic CRD client which is used by client builders default implementation to build the CRDs client
	 *
	 * @return A {@link NonNamespaceOperation} instance that represents a
	 */
	protected abstract NonNamespaceOperation<CustomResourceDefinition, CustomResourceDefinitionList, Resource<CustomResourceDefinition>> customResourceDefinitionsClient();

	/**
	 * Get a client capable of working with {@link Kafka} custom resource.
	 *
	 * @return client for operations with {@link Kafka} custom resource
	 * @deprecated Use {@link KafkaOperatorProvisioner#kafkaResourceClient()} instead.
	 */
	@Deprecated
	public NonNamespaceOperation<Kafka, KafkaList, Resource<Kafka>> kafkasClient() {
		return kafkaResourceClient();
	}

	/**
	 * Get a client capable of working with {@link Kafka} Custom Resources.
	 *
	 * @return Client for operations with {@link Kafka} CRs.
	 */
	public NonNamespaceOperation<Kafka, KafkaList, Resource<Kafka>> kafkaResourceClient() {
		return Crds.kafkaOperation(this.client()).inNamespace(this.client().getNamespace());
	}

	/**
	 * Get a client capable of working with {@link KafkaNodePool} custom resource.
	 *
	 * @return client for operations with {@link KafkaNodePool} custom resource
	 */
	public NonNamespaceOperation<KafkaNodePool, KafkaNodePoolList, Resource<KafkaNodePool>> kafkaNodePoolResourceClient() {
		return Crds.kafkaNodePoolOperation(this.client()).inNamespace(this.client().getNamespace());
	}

	/**
	 * Get a client capable of working with {@link KafkaUser} custom resource.
	 *
	 * @return client for operations with {@link KafkaUser} custom resource
	 * @deprecated Use {@link KafkaOperatorProvisioner#kafkaUserResourceClient()} instead.
	 */
	@Deprecated
	public NonNamespaceOperation<KafkaUser, KafkaUserList, Resource<KafkaUser>> kafkasUserClient() {
		return kafkaUserResourceClient();
	}

	/**
	 * Get a client capable of working with {@link KafkaUser} Custom Resources.
	 *
	 * @return Client for operations with {@link KafkaUser} CRs.
	 */
	public NonNamespaceOperation<KafkaUser, KafkaUserList, Resource<KafkaUser>> kafkaUserResourceClient() {
		return Crds.kafkaUserOperation(this.client()).inNamespace(this.client().getNamespace());
	}

	/**
	 * Get a client capable of working with {@link KafkaTopic} custom resource.
	 *
	 * @return client for operations with {@link KafkaTopic} custom resource
	 * @deprecated Use {@link KafkaOperatorProvisioner#kafkaTopicResourceClient()} instead.
	 */
	@Deprecated
	public NonNamespaceOperation<KafkaTopic, KafkaTopicList, Resource<KafkaTopic>> kafkasTopicClient() {
		return kafkaTopicResourceClient();
	}

	/**
	 * Get a client capable of working with {@link KafkaTopic} Custom Resources.
	 *
	 * @return Client for operations with {@link KafkaTopic} CRs.
	 */
	public NonNamespaceOperation<KafkaTopic, KafkaTopicList, Resource<KafkaTopic>> kafkaTopicResourceClient() {
		return Crds.topicOperation(this.client()).inNamespace(this.client().getNamespace());
	}

	/**
	 * Access the {@link Kafka} cluster Custom Resource.
	 *
	 * <p>
	 *     The {@link Kafka} Custom Resource returned is the one that is tied with the
	 * 	   appropriate Application for which this provisioner is created for. The instance is determined based on the name
	 *     value defined in specifications.
	 * </p>
	 * @return returns {@link Kafka} cluster CR instance that is tied with our relevant application only
	 * @deprecated Use {@link KafkaOperatorProvisioner#getKafkaResource()} instead.
	 */
	@Deprecated
	public Resource<Kafka> kafka() {
		return getKafkaResource();
	}

	/**
	 * Access the {@link Kafka} cluster Custom Resource.
	 *
	 * <p>
	 *     The {@link Kafka} Custom Resource returned is the one that is tied with the
	 * 	   {@link org.jboss.intersmash.application.Application} the provisioner instance is created for.
	 * </p>
	 * @return {@link Kafka} cluster CR instance that is tied with the provisioned Kafka service
	 */
	public Resource<Kafka> getKafkaResource() {
		return kafkaResourceClient().withName(getApplication().getKafka().getMetadata().getName());
	}

	/**
	 * Access the list of {@link KafkaUser} cluster Custom Resources.
	 * <p>
	 * <b>Deprecated</b>: use {@link KafkaOperatorProvisioner#getKafkaUserResources()} instead.
	 * @return A List of {@link KafkaUser} cluster CRs.
	 */
	@Deprecated
	public KafkaUserList getUsers() {
		return getKafkaUserResources();
	}

	public KafkaUserList getKafkaUserResources() {
		return kafkaUserResourceClient().list();
	}

	/**
	 * Access the list of {@link KafkaTopic} Custom Resources in the cluster.
	 * <p>
	 * <b>Deprecated</b>: use {@link KafkaOperatorProvisioner#getKafkaTopicResources()} instead.
	 * @return A List of {@link KafkaTopic} cluster CRs.
	 */
	@Deprecated
	public KafkaTopicList getTopics() {
		return getKafkaTopicResources();
	}

	public KafkaTopicList getKafkaTopicResources() {
		return kafkaTopicResourceClient().list();
	}

	/**
	 * Access the list of {@link KafkaNodePool} Custom Resources in the cluster.
	 * @return A List of {@link KafkaNodePool} cluster CRs.
	 */
	public KafkaNodePoolList getKafkaNodePoolResources() {
		return kafkaNodePoolResourceClient().list();
	}
}
